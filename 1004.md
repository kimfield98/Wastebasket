## 10/4(수)

### 과제 설명서

프로그램이 system call을 통해서 OS와 상호 작용할 수 있도록 만들자!

- **동영상 과제 설명**
    - [https://upside-run.notion.site/141c72f565764c4ea4f24c27d5f7dd5e](https://www.notion.so/141c72f565764c4ea4f24c27d5f7dd5e?pvs=21)

---

### **Background**

- OS(kernel)위에서 작동하는 user program은 시스템에 중요한 부분에 접근할 수 있는 특권이 없음
- 우리는 한번에 하나 이상의 프로그램이 실행될 수 있도록 하되 각각의 프로세스들은 하나의 thread만을 가짐
- user program을 실행함으로써 운영체제를 테스트할 예정

---

### **Source Files**

### `process.c`, `process.h`

- ELF 바이너리(=*ELF 실행파일)*들을 로드하고 프로세스를 실행
- ELF 바이너리란?
    
    ** ELF: ELF는 많은 운영체제에서 목적 파일, 공유 라이브러리, 그리고 실행 파일들을 위해 사용되는 파일 포맷*
    
    ELF는 "Executable and Linkable Format"의 약자로, 많은 Unix 및 Unix-like 운영 체제에서 사용되는 이진 파일 포맷입니다. ELF 파일 형식은 실행 파일, 공유 라이브러리, 코어 덤프 등 다양한 목적으로 사용됩니다. ELF는 바이너리 코드와 데이터, 프로그램의 실행에 필요한 다양한 정보를 포함하는 표준화된 파일 형식을 제공하여 여러 종류의 프로그램을 효율적으로 실행할 수 있게 합니다.
    
    ELF 파일은 크게 세 가지 섹션으로 나뉩니다:
    
    1. **헤더 (Header):** ELF 파일의 기본 정보와 구조를 포함합니다. 이 헤더에는 프로그램 헤더 테이블과 섹션 헤더 테이블에 대한 정보도 포함되어 있습니다.
    2. **프로그램 헤더 테이블 (Program Header Table):** 실행 파일이 메모리에서 어떻게 로드되어야 하는지에 대한 정보를 담고 있습니다. 이 테이블은 실행 파일이 메모리에 로드될 때 세그먼트(segment)의 위치와 크기를 정의합니다.
    3. **섹션 헤더 테이블 (Section Header Table):** ELF 파일의 섹션에 대한 정보를 포함합니다. 섹션은 코드, 데이터, 심볼 테이블 등과 같이 여러 부분으로 나눠진 파일의 구성 요소입니다.
    
    ELF 파일은 크로스 플랫폼 호환성을 제공하며, 여러 운영 체제와 아키텍처에서 사용될 수 있도록 설계되었습니다. ELF 형식은 Linux, BSD, Solaris 등 다양한 Unix 계열 운영 체제에서 널리 사용되며, 이 운영 체제들에서 ELF 바이너리를 실행하기 위해서는 ELF 파일의 내용을 올바르게 해석하고 메모리에 로드하여 실행해야 합니다.
    
    ELF 파일은 일반적으로 컴파일된 소스 코드나 어셈블리 코드를 이진 형식으로 변환한 결과물로, 실행 파일이나 공유 라이브러리로 사용됩니다. ELF 바이너리를 로드하고 실행하는 것은 해당 프로그램을 메모리에 올리고 프로세스로 실행시키는 과정을 의미합니다.
    

### `syscall.c`, `syscall.h`

- 유저 프로세스가 일부 커널 기능에 접근하려고 할 때 마다 시스템 콜이 호출됨 (시스템 콜 핸들러의 기본 구조)
- 현재 상태에서는 이때 단지 메세지를 출력하고 유저 프로세스를 종료

### `exception.c`, `exception.h`

- 예외 사항을 처리 (현재는 단지 메세지를 출력하고 프로세스를 끝냄)
- 일부 해결책은 이 파일 내에 있는 `page_fault()`를 수정
- 유저 프로그램이 특별한 접근 권한을 필요로 하거나 금지된 연산을 수행할 때, 이는 `exception` 또는 `fault`로 커널 내로 트랩
- 트랩이란?
    
    트랩(Trap)은 컴퓨터 시스템에서 발생한 예외나 오류 상황을 처리하기 위해 커널이나 운영체제에 의해 사용되는 메커니즘입니다. 특히, 사용자 프로그램이 특별한 접근 권한이 필요하거나 금지된 연산을 수행하려고 할 때 트랩이 발생합니다.
    
    트랩은 일종의 하드웨어 인터럽트로, 커널은 이를 감지하고 적절한 처리를 수행합니다. 예를 들어, 사용자 프로그램이 허용되지 않은 메모리 영역에 접근하려고 하거나 특권 명령을 실행하려고 할 때, 하드웨어는 이를 감지하고 트랩을 발생시킵니다.
    
    트랩은 일반적으로 다음과 같은 상황에서 발생합니다:
    
    1. **시스템 콜 (System Call):** 사용자 프로그램이 운영체제에 서비스를 요청할 때 발생합니다. 이때 사용자 모드에서 커널 모드로 전환됩니다.
    2. **페이지 폴트 (Page Fault):** 필요한 데이터나 명령이 메모리에 없는 경우 발생합니다.
    3. **부적절한 명령 (Illegal Instruction):** 금지된 명령어를 실행하려고 할 때 발생합니다.
    4. **나누기 0 (Divide by Zero):** 0으로 나누려고 할 때 발생합니다.
    
    트랩이 발생하면, 커널은 해당 예외를 처리하고 문제를 해결하기 위한 조치를 취합니다. 이것은 시스템의 안정성과 보안을 유지하기 위한 중요한 부분입니다. 프로그램이 런타임 중에 발생하는 오류나 문제를 적절히 처리하지 않으면, 시스템이 예측할 수 없는 동작을 보일 수 있습니다.
    
- ** 응용프로그램이 시스템 콜을 호출하면 하드웨어는 ‘트랩 핸들러’를 실행하여 하드웨어 특권 수준을 커널모드로 격상시킴 (커널모드에서 운영체제는 시스템 하드웨어를 자유롭게 접근할 수 있음)*

---

### **Using the File System**

<aside>
💡 이번 프로젝트에서 이 파일 시스템 코드를 수정할 필요도 없고, 수정하지 않기를 권함

</aside>

---

### **Test**

반드시 테스트 프로그램(유저 공간에서 돌고 있는)을 핀토스 가상 공간에 넣어줘야 하지만, `make check` 와 같은 테스팅 스크립트들이 자동적으로 위 과정을 다룸

---

### **How User Programs Work**

- 이 프로젝트에서 쓰이는 어느 시스템 콜도 메모리 할당을 허락하지 않음 (`malloc()` 구현 불가)
- 커널은 문맥 교환이 일어날 때 프로세서의 부동 소수점을 저장하고 복구하지 않음 (부동소수점 연산 사용 프로그램 불가)
- 다양한 프로그램들을 파일 시스템에 복사하기 전까지는 아무런 작업을 할 수 없
- 간혹 디버깅을 하다 보면 filesys.dsk가 사용 불가능한 상태가 되는 경우가 발생할텐데, 복사해서 덮어쓸 수 있는 클린한 레퍼런스 파일 시스템 디스크를 만들어 놓으면 좋음

---

### **Virtual Memory Layout**

- 1) 유저 가상 메모리
    - 가상 주소 0부터 KERN_BASE까지의 범위를 가짐
    - KERN_BASE는 include/threads/vaddr.h에 정의되어 있고 기본적으로 `0x8004000000` 임.
    - 커널 가상 메모리는 가상 주소 공간의 나머지를 차지
    - 하나의 프로세스는 하나의 유저 가상 메모리를 가짐
    - 프로세스 문맥 교환이 일어날 때, 커널은 프로세서의 ‘페이지 디렉토리 베이스 레지스터’를 바꿈으로써 유저 가상 주소 공간 또한 바꿔줌
    - 스레드 구조체는 하나의 프로세스의 페이지 테이블을 가리키는 포인터를 가지고 있음
- 2) 커널 가상 메모리
    - 전역적
    - 어떠한 유저 프로세스 또는 커널 스레드가 CPU 제어권을 획득해 running인지에 관계 없이 항상 같은 방식으로 mapping
    - 가상 주소인 `KERN_BASE`는 물리 주소 `0`에 mapping
    - 가상 주소 `KERN_BASE + 0x1234`물리 주소 `0x1234`에 mapping
    - 이 mapping 방식은 머신의 물리 메모리 사이즈까지 유효

<aside>
💡 유저 프로그램은 자신의 유저 가상 메모리에만 접근할 수 있음.
유저 프로그램이 커널 가상 메모리에 접근하려는 시도는 page fault를 야기하고 프로세스는 종료됨.
`userprog/exception.c` - `page_fault()` 가 page fault 생성

커널 스레드들은 커널 가상 메모리에 접근 가능
만일 유저 프로세스가 running 상태라면 이 유저 프로세스의 유저 가상 메모리에도 접근할 수 있음.
하지만, 커널에서 매핑되지 않은 유저 가상 주소로 메모리에 접근하려는 시도는 page fault를 야기함.

</aside>

- PintOS에서 kernel thread의 memory layout
    
    이 코드는 운영 체제의 스레딩 시스템을 다루는 부분으로 보입니다. 주석에 따르면 각 스레드 구조체는 자체 4 KB 페이지에 저장되며, 페이지의 맨 아래에는 스레드 구조체 자체가 위치하고 나머지 페이지는 해당 스레드의 커널 스택을 위해 예약되어 있습니다. 이러한 페이지 레이아웃은 다음과 같습니다:
    
    ```lua
    
          4 kB +---------------------------------+
               |          kernel stack           |
               |                |                |
               |                |                |
               |                V                |
               |         grows downward          |
               |                                 |
               |                                 |
               |                                 |
               |                                 |
               |                                 |
               |                                 |
               |                                 |
               |                                 |
               |                                 |
               +---------------------------------+
               |              magic              |
               |            intr_frame           |
               |                :                |
               |                :                |
               |               name              |
               |              status             |
          0 kB +---------------------------------+
    
    ```
    
    이 페이지 구조에서 중요한 두 가지 점은 다음과 같습니다:
    
    1. **`struct thread`**가 너무 커지지 않도록 해야 합니다. 그렇지 않으면 커널 스택에 충분한 공간이 없을 것입니다. 기본 는 몇 바이트 크기로 유지되어야 합니다. 보통 1 KB 이하로 유지되어야 합니다.
    2. 커널 스택도 너무 커지지 않도록 해야 합니다. 스택이 넘치면 스레드 상태가 손상될 수 있습니다. 따라서 커널 함수에서는 큰 구조체나 배열을 비정적 로컬 변수로 선언해서는 안 됩니다. 대신에 malloc()이나 palloc_get_page()를 사용하여 동적 할당을 해야 합니다.
    
    두 가지 문제 중 하나가 발생하면 일반적으로 thread_current()에서 어설션 실패가 발생합니다. 이 어설션은 실행 중인 스레드의 **`struct thread`**의 **`magic`** 멤버가 THREAD_MAGIC로 설정되어 있는지 확인합니다. 스택 오버플로우는 보통 이 값을 변경하여 어설션을 트리거합니다.
    
    또한, **`elem`** 멤버는 두 가지 목적으로 사용됩니다. 이것은 run queue (thread.c)의 요소이거나 semaphore wait list (synch.c)의 요소일 수 있습니다. 그러나 두 경우 중 하나만 가능하며, ready 상태의 스레드만 run queue에 있고, blocked 상태의 스레드만 세마포어 대기 목록에 있기 때문입니다.
    

---

### **Typical Memory Layout**

- 각각의 프로세스는 자유롭게 자신의 가상 메모리를 배치 가능
- 유저 가상 메모리
    
    ```
    USER_STACK +----------------------------------+
               |             user stack           |
               |                 |                |
               |                 |                |
               |                 V                |
               |           grows downward         |
               |                                  |
               |                                  |
               |                                  |
               |                                  |
               |           grows upward           |
               |                 ^                |
               |                 |                |
               |                 |                |
               +----------------------------------+
               | uninitialized data segment (BSS) |
               +----------------------------------+
               |     initialized data segment     |
               +----------------------------------+
               |            code segment          |
     0x400000  +----------------------------------+
               |                                  |
               |                                  |
               |                                  |
               |                                  |
               |                                  |
           0   +----------------------------------+
    ```
    
- 한 실행파일의 레이아웃을 보기 위해서는 `-p` 옵션과 함께 objdump 명령어를 실행

---

### **Accessing User Memory**

- 커널은 유저 프로그램이 제공한 포인터들을 통해 메모리에 자주 접근해야 함
- 잘못된 포인터들은 커널과 다른 running 프로세스들에게 아무 악영향을 미치지 않고 거부되어져야 함
    - 문제가 되는 프로세스를 종료시키고 그 프로세스의 자원들을 해제
- **유저 메모리 접근을 가장 쉽게 처리할 수 있는 방법 1**
    - 유저가 전달한 포인터에 문제가 없는지 검사한 후에 역참조
    - `thread/mmu.c` 와 `include/threads/vaddr.h` 에 있는 함수 참고
- 유저 메모리 접근을 가장 쉽게 처리할 수 있는 방법 2 (좀 복잡해서 추가 코드 필요)
    - 유저가 전달한 포인터가 `KERN_BASE`보다 아래 부분을 가리키고 있는지 검사한 후에 역참조
    - 잘못된 유저 포인터는 page fault를 발생시킴 (`userprog/exception.c`의 `page_fault()` 우리가 수정해야 함)
- 두 가지 방법 모두에서 리소스 “누수” 주의할 것

---

## **Argument Passing 인자 전달**

```
**호출 규약**

1. 유저-레벨 어플리케이션은 `%rdi`, `%rsi`, `%rdx`, `%rcx`, `%r8`, `%r9` 시퀀스들을 
		전달하기 위해 정수 레지스터를 사용합니다.

2. 호출자는 다음 인스트럭션의 주소(리턴 어드레스)를 스택에 푸시하고,
		피호출자의 첫번째 인스트럭션으로 점프합니다.
		`CALL` 이라는 x86-64 인스트럭션 하나가 이 두 가지를 모두 수행합니다.

3. 피호출자가 실행됩니다.

4. 만약 피호출자가 리턴 값을 가지고 있다면, 리턴 값은 레지스터 RAX에 저장됩니다.

5. 피호출자는 x86-64 인스트럭션인 `RET` *(리턴)*를 사용해서,
		스택에 받았던 리턴 어드레스를 pop하고 그 주소가 가리키는 곳으로 점프함으로써 리턴됩니다.
```

### **Program Startup Details**

- `lib/user/entry.c` 의 `_start()` 함수
    - 유저 프로그램의 시작 포인트
    - `main()` 함수를 감싸고 있음
    
    ```c
    void
    _start (int argc, char *argv[]) {
        exit (main (argc, argv));
    }
    ```
    
- 커널은 유저 프로그램이 실행되는 것을 허가하기 전에, 레지스터에 올라가 있는 초기 함수를 위한 인자를 반드시 넣어줘야 함

```c
`/bin/ls -l foo bar`

1. 명령을 단어들로 쪼갠다. `/bin/ls`, `l`, `foo`, `bar`

2. 이 단어들을 스택의 맨 처음 부분에 놓는다. 순서는 상관 없음(포인터에 의해 참조될 예정)

3. 각 문자열의 주소 + 경계조건을 위한 널포인터를 스택에 오른쪽→왼쪽 순서로 푸시(`argv`의 원소)
		널포인터 경계는 `argv[argc]` 가 널포인터라는 사실을 보장
		이 순서는 `argv[0]`이 가장 낮은 가상 주소를 가진다는 사실을 보장
		word 크기에 정렬된 접근이 정렬되지 않은 접근보다 빠르므로, 
		최고의 성능을 위해서는 스택에 첫 푸시가 발생하기 전에
		스택포인터를 8의 배수로 반올림해야 함

4. `%rsi` 가 `argv` 주소(`argv[0]`의 주소)를 가리키게 하고, `%rdi` 를 `argc` 로 설정

5. 가짜 “리턴 어드레스”를 푸시
	: entry 함수는 절대 리턴되지 않겠지만,
		해당 스택 프레임은 다른 스택 프레임들과 같은 구조를 가져야 한다.
```

- `%rdi` 와 `%rsi`
    
    x86 아키텍처에서 사용되는 레지스터의 이름 중 일부입니다. 이 레지스터들은 함수 호출 시에 인자(argument)를 전달하는 데 사용됩니다. x86 아키텍처에서 함수 호출은 주로 호출자(caller, 호출하는 쪽)가 호출된 함수(callee, 호출된 쪽)에게 데이터를 전달하는 방식으로 이루어집니다.
    
    일반적으로 x86-64 아키텍처에서 사용되는 레지스터 중 함수 호출과 관련된 것들은 다음과 같습니다:
    
    - **RDI (Destination Index):** 첫 번째 인자를 전달하는 데 사용됩니다.
    - **RSI (Source Index):** 두 번째 인자를 전달하는 데 사용됩니다.
    - **RDX (Data Register):** 세 번째 인자를 전달하는 데 사용됩니다.
    - **RCX (Counter Register):** 네 번째 인자를 전달하는 데 사용됩니다.
    
    이 레지스터들은 함수가 호출될 때 호출자가 값을 설정하고, 호출된 함수에서는 이 값을 활용할 수 있습니다.
    

- 유저 프로그램이 시작되기 직전에 스택과 관련 레지스터들의 상태
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/76075372-1c21-4daf-a5f6-d9d130ca41b3/bc9a25b8-b22a-4721-be02-15cf33bceb3f/Untitled.png)
    
    RDI: 4 | RSI: 0x4747ffc0
    
    - 스택 포인터는 `0x4747ffb8`로 초기화될 것
    - 우리가 짠 코드는 `include/threads/vaddr.h`에 정의된 `USER_STACK` 값에서부터 스택을 시작시켜야
    - `<stdio.h>`에 선언된 비표준 함수인 `hex_dump()`는 인자 전달 코드를 디버깅 하는데 유용

---

### **Implement the argument passing 인자 전달의 구현**

### `process_exec()`

현재) 새로운 프로세스들에 인자를 전달하는 것을 지원하지 않음 (단순히 프로그램 파일 이름만 인자로 받아옴)

수정) 공백을 기준으로 여러 단어로 나누어지게 만들어야 함

```c
process_exec("grep foo bar")

두 개의 인자 foo와 bar을 받아서 grep 프로그램을 실행시켜야 함
```

- 커맨드라인에서, 여러 개의 공백은 하나의 공백과 같게 처리
    - `process_exec("grep    foo   bar")` 실행이 위 코드블럭과 같아야 함
    

인자 파싱할 때 참고하면 좋은 파일과 함수

- `include/lib/string.h` - `strtok_r()`
- `lib/string.c`
- `man strtok_r` 실행 시 man 페이지 볼 수 있음
-