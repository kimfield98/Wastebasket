# Today I Learned 💭

> 오늘 할 일 - linkedList 구현하기

**linkedList가 뭐야?**
데이터와 다음 노드를 가리키는 노드로 이루어진 자료구조야
그니까 .. 노드들의 집합인데 '데이터'와 '포인터'를 담고 있는거지

**이게 배열과 뭐가 달라?**
배열과 linkedList는 trade-off 관계야. 한 쪽이 좋아지면 다른 한 쪽은 안좋아지는 그런 관계.
배열은 인덱스를 가지고 있기 때문에 접근이 빨라 O(1)이지 arr[3] 이렇게 하면 바로 찾을 수 있잖아 데이터를 찾는데 성능이 더 우수한거야 **다만 추가/삭제 시 뭐라고했더라 암튼 오래 걸린대 (다시 알아볼게)**
-> 그 뒤에 있는 모든 원소를 움직여야해서? 근데 내가 알기로는 삭제한 기록을 그 자리에 가지고 있는다고 읽었던 것 같은데 그걸 좀 찾아봐야 할 듯(깊은 복사와 얕은 복사)
linkedList는 반대로 뭘 찾으려면 O(n)만큼 걸려 앞에부터 n번까지 타고 찾아봐야해
다만 삽입 삭제가 빠른 것은 다음 노드를 가리키고 있는 정보만 바꿔주면 돼 뭔말인지 느낌오지 (사실 나는 헷갈리는게 포인터를 잘 몰라서 ㅋㅋ 암튼 뒤에 껄 가리키는게 그 노드의 포인터라는 건가 공부해볼게 .. 암튼 그 포인터가 가리키는 노드를 바꾼다는 듯)

연결리스트에서 한쪽 노드만 가리키면 **단일 연결리스트**이고 양쪽을 다 가리키고 있으면 **이중 연결 리스트**야 <-얘는 이전을 가리키는 포인터와 다음을 가리키는 포인터 그리고 데이터까지 세개를 가지고 있는거지

**linkedList에서 왜 메모리 누수를 조심해야하지?** 길이가 가변적이고 일일이 탐색해야하는거 뭐 이런건 이해 했는데 ..

아무튼 오전에 이와 같이 조사해본 결과, 오늘 linkedList를 구현하려면 구조체와 포인터에 대해서 오후동안 공부를 좀 해야할 것 같구만 계속 나오네 제대로 이해해보기!
저녁엔 코드 보면서 이해하고 구현해보고 가기 전에 이거 블로그 초안 써놓고-


낮잠 잠깐 자고 2시부터 구현을 시작하기로 했어 오전에 생각한 부분을 슬랙에 올렸는데 팀원이 구현하면서 왜 그런지 알 수 있을 거라고 해서- <br>
추가적으로 배열은 삽입 삭제가 불가능한 자료구조래 원하면 malloc 등을 사용해서 배열을 새로 만들고 복사해서 추가하거나 삭제하는 기능을 수행해야 한다고 하네 이때 안쓰는건(?) 바로 반환 해지? free를 해줘야하는데 그렇지 않을 경우 메모리 누수가 일어난대 또 잘못 가리키거나 두 번 지우려고 할 경우?도 있다는데 구현 이후에 좀 더 알 수 있을 것 같아

포인터 공부하다가 예시 코드 읽다가 오후가 다 가버렸다 조급한 마음 .. 그래도 차근차근 하자 이상하게 쌓아올린 탑은 무너지기 마련 ! 저녁 일정이 갑자기 생겨서 마무리를 못했으니 내일 일찍 일어나서 합시다요

<br>

# Daily Algorithm 🔥

```py
# [백준 2309 일곱 난쟁이 파이썬](https://www.acmicpc.net/problem/2309)

import sys
input = sys.stdin.readline

# 아홉 난쟁이의 키를 담을 배열 생성
arr = []
# 아홉 줄에 걸쳐 키를 받고 배열에 추가
for _ in range(9):
    height = int(input())
    arr.append(height)
# print(arr)

arr_sum = sum(arr)
new_arr = []
flag = False
# 모든 두 명의 조합을 계산
for i in range(9):
    for j in range(i+1,9):
        # i와 j를 제외한 배열의 합이 100일 경우 i,j를 제외하고 새 배열에 담기
        if arr_sum - arr[i] - arr[j] == 100:
            for idx in range(9):
                if idx == i or idx == j:
                    continue
                new_arr.append(arr[idx])
            flag = True
            break
    
    if flag:
        break


# 오름차순으로 한 줄씩 출력
new_arr.sort()
for i in new_arr:
    print(i)
```

- 모든 두 명의 조합을 계산해야겠다는 생각까지는 도달했으나 코드(이중 반복문)로 이어지지 않아서 이전 제출한 답안을 봄
- `new_arr`의 위치만 `for문`을 벗어났을 뿐인데 `틀렸습니다` 처리가 되어서, 마지막 값만으로 갱신되지 않도록 안에 넣어줘야겠다고만 생각했는데, 다른 동기가 `new_arr`의 위치를 바꾸지 않고 반복문 안에서 `flag` 처리를 했더니 정답처리가 되었다. 아직도 제어문을 잘 모른다 ..